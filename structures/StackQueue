#include <iostream>
#include <cstdio>

//Stack v0.3.0
template <typename T>
class Stack{
public:
    Stack();
    ~Stack();
    void                        push(T val);
    T                           pop();
    T                           min();
    T                           max();
    int                         size();
    T                           back();
    void                        clear();

    template <typename Y>
    friend void popPush (Stack <Y> & popFrom, Stack <Y> & pushTo);

private:
    struct  Node{
        T       val;
        T       min;
        T       max;
        Node *  next;
    };

    Node *  top_;
    int     size_;
};

template <typename T>
void popPush(Stack <T> & popFrom, Stack <T> & pushTo);

//=============================================================================

//StackQueue v0.3.0
template <typename T>
class StackQueue{
public:
    StackQueue();
    ~StackQueue();
    void    enqueue(T val);
    T       dequeue();
    T       front();
    int     size();
    void    clear();
    T       min();

private:
    Stack <T>   stack1_;
    Stack <T>   stack2_;
    int         size_;
    void        shift();
};

//=============================================================================



//===========================STACK=============================================

template <typename T>
Stack<T>::Stack(){
    top_ = NULL;
    size_ = 0;
}

template <typename T>
Stack<T>::~Stack(){
    clear();
}

template <typename T>
void Stack<T>::push(T val){
    Node * tmp = new Node;
    tmp->val = val;
    tmp->next = top_;
    top_ = tmp;
    size_++;
    if(size_ <= 1)
        top_->min = val;
    else if(top_->next->min > val)
        top_->min = val;
    else
        top_->min = top_->next->min;
    if(size_ <= 1)
        top_->max = val;
    else if(top_->next->max < val)
        top_->max = val;
    else
        top_->max = top_->next->max;
}

template <typename T>
T Stack<T>::pop(){
    if(size_ == 0){
        std::cerr << "Stack::pop() : Empty stack\n";
    }
    Node * tmp = top_;
    top_ = top_->next;
    size_--;
    T val = tmp->val;
    delete tmp;
    return val;
}

template <typename T>
T Stack<T>::min(){
    return top_->min;
}

template <typename T>
T Stack<T>::max(){
    return top_->max;
}

template <typename T>
int Stack<T>::size(){
    return size_;
}

template <typename T>
T Stack<T>::back(){
    if(size_ == 0){
        std::cerr << "Stack::back() : Empty stack\n";
    }
    return top_->val;
}

template <typename T>
void Stack<T>::clear(){
    while(size_ != 0){
        Node * tmp = top_;
        top_ = top_->next;
        delete tmp;
        size_--;
    }
    top_ = NULL;
}

template <typename T>
void popPush(Stack <T> & popFrom, Stack <T> & pushTo){
    if(popFrom.size_ == 0){
        std::cerr << "popPush() : Empty stack\n";
    }
    typename Stack<T>::Node * tmp = popFrom.top_;
    popFrom.top_ = popFrom.top_->next;
    popFrom.size_--;

    tmp->next = pushTo.top_;
    pushTo.top_ = tmp;
    pushTo.size_++;
    if(pushTo.size_ <= 1)
        pushTo.top_->min = pushTo.top_->val;
    else if(pushTo.top_->next->min > pushTo.top_->val)
        pushTo.top_->min = pushTo.top_->val;
    else
        pushTo.top_->min = pushTo.top_->next->min;
    if(pushTo.size_ <= 1)
        pushTo.top_->max = pushTo.top_->val;
    else if(pushTo.top_->next->max < pushTo.top_->val)
        pushTo.top_->max = pushTo.top_->val;
    else
        pushTo.top_->max = pushTo.top_->next->max;
}

//===========================STACKQUEUE========================================

template <typename T>
StackQueue<T>::StackQueue(){
    size_ = 0;
}

template <typename T>
StackQueue<T>::~StackQueue(){
    clear();
}

template <typename T>
void StackQueue<T>::enqueue(T val){
    stack1_.push(val);
    size_++;
}

template <typename T>
void StackQueue<T>::shift(){
    while(stack1_.size()){
        popPush(stack1_, stack2_);
    }
}

template <typename T>
T StackQueue<T>::dequeue(){
    if(size_ == 0){
        std::cerr << "StackQueue::dequeue : empty queue \n";
    }
    if(!stack2_.size())
        shift();
    size_--;
    return stack2_.pop();
}

template <typename T>
T StackQueue<T>::front(){
    if(size_ == 0){
        std::cerr << "StackQueue::front : empty queue \n";
    }
    if(!stack2_.size())
        shift();
    return stack2_.back();
}

template <typename T>
int StackQueue<T>::size(){
    return size_;
}

template <typename T>
void StackQueue<T>::clear(){
    stack1_.clear();
    stack2_.clear();
    size_ = 0;
}

template <typename T>
T StackQueue<T>::min(){
    if(size_ == 0){
        std::cerr << "Queue::min : empty queue \n";
    }
    if(stack1_.size() == 0)
        return stack2_.min();
    else if(stack2_.size() == 0)
        return stack1_.min();
    else
        return std::min(stack1_.min(), stack2_.min());
}
