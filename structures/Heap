#include <iostream>
#include <cstdio>

//Heap v0.0.1
template <typename T>
class Heap{
public:
                Heap();
                ~Heap();
    void        insert(T val);
    T           extract_min();
    T           get_min();
    int         size();
    void        clear();
    void        print();

private:
    void        siftUp(int index);
    void        siftDown(int index);

    T *         buffer_;
    int         defaultSize_;
    int         bufferSize_;
    int         size_;
};

//=============================================================================

//===========================HEAP==============================================

template <typename T>
Heap<T>::Heap():
defaultSize_(16),
bufferSize_(defaultSize_),
size_(0)
{
    buffer_ = new T[bufferSize_];
}

template <typename T>
Heap<T>::~Heap(){
    delete[] buffer_;
}

template <typename T>
void Heap<T>::siftUp(int index){
    if(index >= size_)
        std::cerr << "Heap::siftUp : Wrong index\n";
    while(index && buffer_[index] < buffer_[(index - 1)/2]){/**/
        T tmp = buffer_[index];
        buffer_[index] = buffer_[(index - 1)/2];
        buffer_[(index - 1)/2] = tmp;
        index = (index - 1)/2;
    }
}

template <typename T>
void Heap<T>::siftDown(int index){
    if(index >= size_)
        std::cerr << "Heap::siftDown : Wrong index\n";
    int min = index;
    if(index*2 + 1 < size_ && buffer_[index*2 + 1] < buffer_[min])
        min = index*2 + 1;
    if(index*2 + 2 < size_ && buffer_[index*2 + 2] < buffer_[min])
        min = index*2 + 2;
    if(min != index){
        T tmp = buffer_[index];
        buffer_[index] = buffer_[min];
        buffer_[min] = tmp;
        siftDown(min);
    }
}

template <typename T>
void Heap<T>::insert(T val){
    if(size_ + 1 > bufferSize_){
        T * tmp = new T[bufferSize_*2];
        for(int i = 0; i < bufferSize_; i++)
            tmp[i] = buffer_[i];
        delete[] buffer_;
        buffer_ = tmp;
        bufferSize_ *= 2;
    }
    buffer_[size_] = val;
    size_++;
    siftUp(size_ - 1);
}

template <typename T>
T Heap<T>::extract_min(){
    if(!size_)
        std::cerr << "Heap::extract_min : Empty heap\n";
    T min = buffer_[0];
    buffer_[0] = buffer_[size_ - 1];
    size_--;
    if(size_)
        siftDown(0);
    return min;
}

template <typename T>
T Heap<T>::get_min(){
    if(!size_)
        std::cerr << "Heap::get_min : Empty heap\n";
    return buffer_[0];
}

template <typename T>
int Heap<T>::size(){
    return size_;
}

template <typename T>
void Heap<T>::clear(){
    delete[] buffer_;
    buffer_ = new T[defaultSize_];
    bufferSize_ = defaultSize_;
    size_ = 0;
}

template <typename T>
void Heap<T>::print(){
    for(int i = 0; i < size_; i++)
        printf("%d ", buffer_[i]);
    printf("\n");
}
